Implement an interface for the CodeType object.

The Python Monitoring API passes a CodeObject to each event handler. In the current implemenation of our Tracer trait the event handlers have an argument `_code: &Bound<'_, PyAny>` which gives
access to this object. This is not a good interface because the type is too generic. PyO3 has a PyCodeObject type, however it doesn't expose any public members because the type is unstable,
so we cannot use that one.

We need to create our own type CodeObjectWrapper which can simplify access to the underlying code object type. Then we should use this type in the signature of the methods in the Tracer trait.
The type should allow easy access to that functionality of the underlying code object which we will need to implement a recorder for a time-travel debugger. 
On the other hand it is important not to introduce any performance problems. Some ideas to think about:
- Minimize the copying of values
- Repeated computations on each event call could be memoized
- Any other approach that minimizes the performance hit

Propose a design of the CodeObjectWrapper type. Write the design in design-docs/code-object.md. Do not actually implement the type for now, I need to confirm the design first.

Here's relevant information:
* design-docs/design-001.md - shows how we write design documentation
* https://docs.python.org/3/library/sys.monitoring.html - Documentation of the Python sys.montoring API
* https://docs.python.org/3/reference/datamodel.html#code-objects - Description of Python Code Objects.

--- FOLLOW UP TASK ---
Please address any inline comments on the diff, as well as any additional instructions below.

According to the PyO3 documentation it is preferred to use  instead of Py<T>. Is it possible that the code object wrapper takes that into account? Here is relevant info:
* https://pyo3.rs/v0.25.1/types.html
* https://docs.rs/pyo3/0.25.1/pyo3/index.html

Also please add usage examples to the design documentation
--- FOLLOW UP TASK ---
Please address any inline comments on the diff, as well as any additional instructions below.

According to the PyO3 documentation it is preferred to use `Bound<'_, T>` instead of Py<T>. Is it possible that the code object wrapper takes that into account? Here is relevant info:
* https://pyo3.rs/v0.25.1/types.html
* https://docs.rs/pyo3/0.25.1/pyo3/index.html

Also please add usage examples to the design documentation
--- FOLLOW UP TASK ---
Implement the CodeObjectWrapper as designed. Update the Tracer trait as well as the callback_xxx functions accordingly. Write a comprehensive unit tests for CodeObjectWrapper.
--- FOLLOW UP TASK ---
There is an issue in the current implementation. We don't use caching effectively, since we create a new CodeObjectWrapper at each callback_xxx call. We need a global cache, probably keyed by the code object id. Propose design changes and update the design documents. Don't implement the changes themselves before I approve them.
--- FOLLOW UP TASK ---
Implement the global code object registry.

--- FOLLOW UP TASK ---
Take a look at agents.just and scripts/. Also at the design docs for jj-workspaces. This is a proof-of-concept solution for defining and running agent workflows defined by the user. I want to create a real product based on this s proof of concept.\n\nUsers should be able to define their own workflows. They should also be able to publish workflows and fetch them from a central repository. It should be possible to parallelize work - be able to work on several workflows at once.\n\nCreate a technical specification for the components that need to be developed for this product. We will use Rust as our main programming language
--- FOLLOW UP TASK ---
In previous turns, the user had the following interaction with the agent:

<TURN_1>
<USER_INPUT>
Take a look at agents.just and scripts/. Also at the design docs for jj-workspaces. This is a proof-of-concept solution for defining and running agent workflows defined by the user. I want to create a real product based on this s proof of concept.

Users should be able to define their own workflows. They should also be able to publish workflows and fetch them from a central repository. It should be possible to parallelize work - be able to work on several workflows at once.

Create a technical specification for the components that need to be developed for this product. We will use Rust as our main programming language 
</USER_INPUT>
<ASSISTANT_OUTPUT>

**Summary**
* Authored a comprehensive workflow automation platform specification covering product goals, requirements, and a full Rust-based architecture spanning workflow definitions, execution engine, workspace manager, CLI, registry services, observability, and packaging considerations.


* Documented migration steps from the existing proof of concept along with open questions to guide the transition to the production platform.



**Testing**
* ⚠️ Not run (not requested for documentation-only change).

</ASSISTANT_OUTPUT>
</TURN_1>


The user was unsatisfied with the code that the agent previously produced, which can be found as the latest commit in the git history.

<PREVIOUS_PR_TITLE>
docs: add workflow automation platform spec
</PREVIOUS_PR_TITLE>

<PREVIOUS_PR_DESCRIPTION>
## Summary
- add a technical specification for the workflow automation product
- describe requirements, system architecture, and crate breakdown for a Rust implementation
- cover registry service, CLI, executor, workspace management, observability, and migration steps

## Testing
- not run (documentation-only change)

</PREVIOUS_PR_DESCRIPTION>

<PREVIOUS_PR_DIFF_AND_COMMENTS>
diff --git a/.agents/tasks/2025/08/21-0939-codetype-interface b/.agents/tasks/2025/08/21-0939-codetype-interface
(File changed with 3 additions, 0 deletions)
diff --git a/None b/design-docs/workflow-platform-spec.md
(File changed with 283 additions, 0 deletions)
</PREVIOUS_PR_DIFF_AND_COMMENTS>

Please address any inline comments on the diff, as well as any additional instructions below.

Now write a PR/FAQ document for this product. If there are important questions whose answers are unclear add them to the FAQ but don't write an answer 